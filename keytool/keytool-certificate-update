Use keytool explorer s/w to check if certigicate is ok and have pass or not and also store this cert in file format variables in gitlab
Copy old certificate variabls beforehand

get certificate in .p12 format and should not have any password

	1) This will change the password of your keystore to an empty password

keytool -storetype pkcs12 -keystore ~/Downloads/dev.pem.p12  -storepasswd -storepass ''

	1) This invokes the OpenSSL tool to perform base64 encoding

openssl base64 -in ~/Downloads/dev.pem.p12  -out devp12222.txt

cat prodp12222.txt
---------
Prerequisites:-

Reference to the GitLab .gitlab-ci.yml Â· main 
Have .p12 certificates for each environment.
No password set on certificates .
Download and installation of KeyTool Explorer software.
Backup of old environment variable values in GitLab.

Step 1: Verify and Prepare Certificates
Check Certificate Using KeyTool Explorer:
Open the dev.p12 certificate file in KeyTool Explorer software.
Verify if the certificate requires a password:
If prompted for a password and can proceed without entering one, note that it is passwordless.
If a password is required, proceed to set the _KEYSTORE_PASSWORD value accordingly for automation.

Step 2: Base64 Encode Certificates
You have two methods to encode the certificate in base64 format:

Option 1: Using openssl directly

openssl base64 -in ~/Downloads/dev.p12 -out devp12222.txt

Option 2: Using cat and base64

cat ~/Downloads/dev.p12 | base64 -w 0 > devp12222.txt

Verify the Encoded File
cat devp12222.txt

Ensure that the content displayed matches the expected base64-encoded certificate.

Step 3: Update Environment Variables
Update the environment variables in your Infrastructure project with the .txt files obtained from Step 2 and have variable of type(File Protected Expanded)

Example of Updating Environment Variables:
DEV_KEYSTORE: Assign the base64-encoded certificate file (devp12222.txt) content.
DEV_KEYSTORE_PASSWORD: set the password value _KEYSTORE_PASSWORD.
Repeat the above for other environments (PREPROD, PROD) as necessary.

---

deploy-develop:
  stage: deploy-develop
  image: kustomize-kubectl-helm-cosign-kics
  tags:
    - $KUBERNETES_RUNNER
  variables:
    KUBERNETES_SHORTNAME : $DEV_KUBERNETES_SHORTNAME
    KUBERNETES_URL : $DEV_KUBERNETES_URL
    KUBERNETES_USER : $DEV_KUBERNETES_USER
    KUBERNETES_USER_TOKEN : $DEV_KUBERNETES_USER_TOKEN
    KUBERNETES_NAMESPACE: dev
    MONGODB_USER_PASSWORD: $DEV_MONGODB_USER_PASSWORD
    DEV_KEYSTORE: $DEV_KEYSTORE
    DEV_KEYSTORE_PASSWORD: $DEV_KEYSTORE_PASSWORD
  script:
    - kubectl config set-cluster $KUBERNETES_SHORTNAME --server=$KUBERNETES_URL
    - kubectl config set-credentials $KUBERNETES_USER --token=$KUBERNETES_USER_TOKEN
    - kubectl config set-context $KUBERNETES_NAMESPACE --cluster=$KUBERNETES_SHORTNAME --namespace=$KUBERNETES_NAMESPACE --user=$KUBERNETES_USER
    - kubectl config use-context $KUBERNETES_NAMESPACE
    - kubectl create secret generic cosign  --from-file=cosign.pub=$COSIGN_PUB --dry-run=client -o yaml | kubectl apply -f -
    - kubectl apply -f kubernetes/telekom/dev/workflow-engine-secret.yaml
    - cat $DEV_KEYSTOR | base64 --decode > keystore.p12
    - kubectl create secret generic java-keystore --from-file=keystore.p12=keystore.p12 --from-file=ks-password=$DEV_KEYSTORE_PASSWORD --dry-run=client -o yaml | kubectl apply -f -
    - echo "$(envsubst '${MONGODB_USER_PASSWORD},${CLIENT_SECRET},${CLIENT_SECRET_DEV},${CLIENT_SECRET_PREPROD},${CLIENT_SECRET_CIT2}' < kubernetes/telekom/dev/configmap-env.yaml)" > kubernetes/telekom/dev/configmap-env.yaml
    - cd kubernetes/dev
    - kustomize build . | kubectl apply -f -
  only:
    variables:
      - $ENVIRONMENT =~ "JADU"
  environment:
    name: develop

